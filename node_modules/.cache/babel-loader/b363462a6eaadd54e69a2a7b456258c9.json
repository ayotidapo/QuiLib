{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, Flickity, Unidragger, utils) {\n  // ----- defaults ----- //\n  Object.assign(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  }); // -------------------------- drag prototype -------------------------- //\n\n  let proto = Flickity.prototype;\n  Object.assign(proto, Unidragger.prototype); // inherit Unidragger\n\n  proto.touchActionValue = ''; // --------------------------  -------------------------- //\n\n  Flickity.create.drag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    this.on('pointerDown', this.handlePointerDown);\n    this.on('pointerUp', this.handlePointerUp);\n    this.on('pointerDown', this.handlePointerDone);\n    this.on('dragStart', this.handleDragStart);\n    this.on('dragMove', this.handleDragMove);\n    this.on('dragEnd', this.handleDragEnd);\n    this.on('staticClick', this.handleStaticClick); // TODO updateDraggable on resize? if groupCells & slides change\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable === '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n\n    this.element.classList.toggle('is-draggable', this.isDraggable);\n  };\n\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  }; // -------------------------- pointer events -------------------------- //\n\n\n  proto.handlePointerDown = function (event) {\n    if (!this.isDraggable) {\n      // proceed for staticClick\n      this.bindActivePointerEvents(event);\n      return;\n    }\n\n    let isTouchStart = event.type === 'touchstart';\n    let isTouchPointer = event.pointerType === 'touch';\n    let isFocusNode = event.target.matches('input, textarea, select');\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) event.preventDefault();\n    if (!isFocusNode) this.focus(); // blur\n\n    if (document.activeElement !== this.element) document.activeElement.blur(); // stop if it was moving\n\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down'); // track scrolling\n\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n    this.bindActivePointerEvents(event);\n  }; // ----- move ----- //\n\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  }; // ----- up ----- //\n\n\n  proto.handlePointerUp = function () {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n  };\n\n  proto.handlePointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  }; // -------------------------- dragging -------------------------- //\n\n\n  proto.handleDragStart = function () {\n    if (!this.isDraggable) return;\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n  };\n\n  proto.handleDragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) return;\n    event.preventDefault();\n    this.previousDragX = this.dragX; // reverse if right-to-left\n\n    let direction = this.options.rightToLeft ? -1 : 1; // wrap around move. #589\n\n    if (this.isWrapping) moveVector.x %= this.slideableWidth;\n    let dragX = this.dragStartPosition + moveVector.x * direction;\n\n    if (!this.isWrapping) {\n      // slow drag\n      let originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      let endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n  };\n\n  proto.handleDragEnd = function () {\n    if (!this.isDraggable) return;\n    let {\n      freeScroll\n    } = this.options;\n    if (freeScroll) this.isFreeScrolling = true; // set selectedIndex based on where flick will end up\n\n    let index = this.dragEndRestingSelect();\n\n    if (freeScroll && !this.isWrapping) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      let restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!freeScroll && index === this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n\n    delete this.previousDragX; // apply selection\n    // HACK, set flag so dragging stays in correct direction\n\n    this.isDragSelect = this.isWrapping;\n    this.select(index);\n    delete this.isDragSelect;\n  };\n\n  proto.dragEndRestingSelect = function () {\n    let restingX = this.getRestingPosition(); // how far away from selected slide\n\n    let distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex)); // get closet resting going up and going down\n\n    let positiveResting = this._getClosestResting(restingX, distance, 1);\n\n    let negativeResting = this._getClosestResting(restingX, distance, -1); // use closer resting for wrap-around\n\n\n    return positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n  };\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n\n\n  proto._getClosestResting = function (restingX, distance, increment) {\n    let index = this.selectedIndex;\n    let minDistance = Infinity;\n    let condition = this.options.contain && !this.isWrapping ? // if containing, keep going if distance is equal to minDistance\n    (dist, minDist) => dist <= minDist : (dist, minDist) => dist < minDist;\n\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) break;\n      distance = Math.abs(distance);\n    }\n\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n\n\n  proto.getSlideDistance = function (x, index) {\n    let len = this.slides.length; // wrap around if at least 2 slides\n\n    let isWrapAround = this.options.wrapAround && len > 1;\n    let slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    let slide = this.slides[slideIndex];\n    if (!slide) return null; // add distance for wrap-around slides\n\n    let wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime || // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n\n    let distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    let delta = this.previousDragX - this.dragX;\n\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n\n    return 0;\n  }; // ----- scroll ----- //\n\n\n  proto.onscroll = function () {\n    let scroll = getScrollPosition();\n    let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    let scrollMoveY = this.pointerDownScroll.y - scroll.y; // cancel click/tap if scroll is too much\n\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this.pointerDone();\n    }\n  }; // ----- utils ----- //\n\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  } // -----  ----- //\n\n\n  return Flickity;\n});","map":{"version":3,"sources":["/Users/oti/Documents/QuiLib/node_modules/flickity/js/drag.js"],"names":["window","factory","module","exports","require","Flickity","Unidragger","fizzyUIUtils","utils","Object","assign","defaults","draggable","dragThreshold","proto","prototype","touchActionValue","create","drag","on","onActivateDrag","_uiChangeDrag","onDeactivateDrag","updateDraggable","handlePointerDown","handlePointerUp","handlePointerDone","handleDragStart","handleDragMove","handleDragEnd","handleStaticClick","handles","viewport","bindHandles","unbindHandles","element","classList","remove","options","isDraggable","slides","length","toggle","isFreeScrolling","event","bindActivePointerEvents","isTouchStart","type","isTouchPointer","pointerType","isFocusNode","target","matches","preventDefault","focus","document","activeElement","blur","dragX","x","add","pointerDownScroll","getScrollPosition","addEventListener","hasDragStarted","moveVector","Math","abs","isTouchScrolling","removeEventListener","dragStartPosition","startAnimation","pointer","previousDragX","direction","rightToLeft","isWrapping","slideableWidth","originBound","max","endBound","min","getLastSlide","dragMoveTime","Date","freeScroll","index","dragEndRestingSelect","restingX","getRestingPosition","selectedIndex","dragEndBoostSelect","isDragSelect","select","distance","getSlideDistance","positiveResting","_getClosestResting","negativeResting","increment","minDistance","Infinity","condition","contain","dist","minDist","len","isWrapAround","wrapAround","slideIndex","modulo","slide","wrap","floor","undefined","delta","onscroll","scroll","scrollMoveX","scrollMoveY","y","pointerDone","pageXOffset","pageYOffset"],"mappings":"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","sourcesContent":["// drag\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./core'),\n        require('unidragger'),\n        require('fizzy-ui-utils'),\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n        window,\n        window.Flickity,\n        window.Unidragger,\n        window.fizzyUIUtils,\n    );\n  }\n\n}( typeof window != 'undefined' ? window : this,\n    function factory( window, Flickity, Unidragger, utils ) {\n\n// ----- defaults ----- //\n\nObject.assign( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n} );\n\n// -------------------------- drag prototype -------------------------- //\n\nlet proto = Flickity.prototype;\nObject.assign( proto, Unidragger.prototype ); // inherit Unidragger\nproto.touchActionValue = '';\n\n// --------------------------  -------------------------- //\n\nFlickity.create.drag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'deactivate', this.onDeactivateDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  this.on( 'pointerDown', this.handlePointerDown );\n  this.on( 'pointerUp', this.handlePointerUp );\n  this.on( 'pointerDown', this.handlePointerDone );\n  this.on( 'dragStart', this.handleDragStart );\n  this.on( 'dragMove', this.handleDragMove );\n  this.on( 'dragEnd', this.handleDragEnd );\n  this.on( 'staticClick', this.handleStaticClick );\n  // TODO updateDraggable on resize? if groupCells & slides change\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable === '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  this.element.classList.toggle( 'is-draggable', this.isDraggable );\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.handlePointerDown = function( event ) {\n  if ( !this.isDraggable ) {\n    // proceed for staticClick\n    this.bindActivePointerEvents( event );\n    return;\n  }\n\n  let isTouchStart = event.type === 'touchstart';\n  let isTouchPointer = event.pointerType === 'touch';\n  let isFocusNode = event.target.matches('input, textarea, select');\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) event.preventDefault();\n  if ( !isFocusNode ) this.focus();\n  // blur\n  if ( document.activeElement !== this.element ) document.activeElement.blur();\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n  this.bindActivePointerEvents( event );\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.handlePointerUp = function() {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n};\n\nproto.handlePointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.handleDragStart = function() {\n  if ( !this.isDraggable ) return;\n\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n};\n\nproto.handleDragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) return;\n\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  let direction = this.options.rightToLeft ? -1 : 1;\n  // wrap around move. #589\n  if ( this.isWrapping ) moveVector.x %= this.slideableWidth;\n  let dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.isWrapping ) {\n    // slow drag\n    let originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    let endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n  this.dragMoveTime = new Date();\n};\n\nproto.handleDragEnd = function() {\n  if ( !this.isDraggable ) return;\n\n  let { freeScroll } = this.options;\n  if ( freeScroll ) this.isFreeScrolling = true;\n  // set selectedIndex based on where flick will end up\n  let index = this.dragEndRestingSelect();\n\n  if ( freeScroll && !this.isWrapping ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    let restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !freeScroll && index === this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.isWrapping;\n  this.select( index );\n  delete this.isDragSelect;\n};\n\nproto.dragEndRestingSelect = function() {\n  let restingX = this.getRestingPosition();\n  // how far away from selected slide\n  let distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  let positiveResting = this._getClosestResting( restingX, distance, 1 );\n  let negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  return positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  let index = this.selectedIndex;\n  let minDistance = Infinity;\n  let condition = this.options.contain && !this.isWrapping ?\n    // if containing, keep going if distance is equal to minDistance\n    ( dist, minDist ) => dist <= minDist :\n    ( dist, minDist ) => dist < minDist;\n\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) break;\n\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment,\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x - horizontal position\n * @param {Integer} index - slide index\n * @returns {Number} - slide distance\n */\nproto.getSlideDistance = function( x, index ) {\n  let len = this.slides.length;\n  // wrap around if at least 2 slides\n  let isWrapAround = this.options.wrapAround && len > 1;\n  let slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  let slide = this.slides[ slideIndex ];\n  if ( !slide ) return null;\n\n  // add distance for wrap-around slides\n  let wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  let distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  let delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  let scroll = getScrollPosition();\n  let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  let scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this.pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset,\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"]},"metadata":{},"sourceType":"script"}