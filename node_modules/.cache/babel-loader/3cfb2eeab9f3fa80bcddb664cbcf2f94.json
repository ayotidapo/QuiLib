{"ast":null,"code":"/*!\n * Unidragger v3.0.1\n * Draggable base class\n * MIT license\n */\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('ev-emitter'));\n  } else {\n    // browser global\n    window.Unidragger = factory(window, window.EvEmitter);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, EvEmitter) {\n  function Unidragger() {} // inherit EvEmitter\n\n\n  let proto = Unidragger.prototype = Object.create(EvEmitter.prototype); // ----- bind start ----- //\n  // trigger handler methods for events\n\n  proto.handleEvent = function (event) {\n    let method = 'on' + event.type;\n\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  let startEvent, activeEvents;\n\n  if ('ontouchstart' in window) {\n    // HACK prefer Touch Events as you can preventDefault on touchstart to\n    // disable scroll in iOS & mobile Chrome metafizzy/flickity#1177\n    startEvent = 'touchstart';\n    activeEvents = ['touchmove', 'touchend', 'touchcancel'];\n  } else if (window.PointerEvent) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n    activeEvents = ['pointermove', 'pointerup', 'pointercancel'];\n  } else {\n    // mouse events\n    startEvent = 'mousedown';\n    activeEvents = ['mousemove', 'mouseup'];\n  } // prototype so it can be overwriteable by Flickity\n\n\n  proto.touchActionValue = 'none';\n\n  proto.bindHandles = function () {\n    this._bindHandles('addEventListener', this.touchActionValue);\n  };\n\n  proto.unbindHandles = function () {\n    this._bindHandles('removeEventListener', '');\n  };\n  /**\n   * Add or remove start event\n   * @param {String} bindMethod - addEventListener or removeEventListener\n   * @param {String} touchAction - value for touch-action CSS property\n   */\n\n\n  proto._bindHandles = function (bindMethod, touchAction) {\n    this.handles.forEach(handle => {\n      handle[bindMethod](startEvent, this);\n      handle[bindMethod]('click', this); // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n\n      if (window.PointerEvent) handle.style.touchAction = touchAction;\n    });\n  };\n\n  proto.bindActivePointerEvents = function () {\n    activeEvents.forEach(eventName => {\n      window.addEventListener(eventName, this);\n    });\n  };\n\n  proto.unbindActivePointerEvents = function () {\n    activeEvents.forEach(eventName => {\n      window.removeEventListener(eventName, this);\n    });\n  }; // ----- event handler helpers ----- //\n  // trigger method with matching pointer\n\n\n  proto.withPointer = function (methodName, event) {\n    if (event.pointerId === this.pointerIdentifier) {\n      this[methodName](event, event);\n    }\n  }; // trigger method with matching touch\n\n\n  proto.withTouch = function (methodName, event) {\n    let touch;\n\n    for (let changedTouch of event.changedTouches) {\n      if (changedTouch.identifier === this.pointerIdentifier) {\n        touch = changedTouch;\n      }\n    }\n\n    if (touch) this[methodName](event, touch);\n  }; // ----- start event ----- //\n\n\n  proto.onmousedown = function (event) {\n    this.pointerDown(event, event);\n  };\n\n  proto.ontouchstart = function (event) {\n    this.pointerDown(event, event.changedTouches[0]);\n  };\n\n  proto.onpointerdown = function (event) {\n    this.pointerDown(event, event);\n  }; // nodes that have text fields\n\n\n  const cursorNodes = ['TEXTAREA', 'INPUT', 'SELECT', 'OPTION']; // input types that do not have text fields\n\n  const clickTypes = ['radio', 'checkbox', 'button', 'submit', 'image', 'file'];\n  /**\n   * any time you set `event, pointer` it refers to:\n   * @param {Event} event\n   * @param {Event | Touch} pointer\n   */\n\n  proto.pointerDown = function (event, pointer) {\n    // dismiss multi-touch taps, right clicks, and clicks on text fields\n    let isCursorNode = cursorNodes.includes(event.target.nodeName);\n    let isClickType = clickTypes.includes(event.target.type);\n    let isOkayElement = !isCursorNode || isClickType;\n    let isOkay = !this.isPointerDown && !event.button && isOkayElement;\n    if (!isOkay) return;\n    this.isPointerDown = true; // save pointer identifier to match up touch events\n\n    this.pointerIdentifier = pointer.pointerId !== undefined ? // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier; // track position for move\n\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    };\n    this.bindActivePointerEvents();\n    this.emitEvent('pointerDown', [event, pointer]);\n  }; // ----- move ----- //\n\n\n  proto.onmousemove = function (event) {\n    this.pointerMove(event, event);\n  };\n\n  proto.onpointermove = function (event) {\n    this.withPointer('pointerMove', event);\n  };\n\n  proto.ontouchmove = function (event) {\n    this.withTouch('pointerMove', event);\n  };\n\n  proto.pointerMove = function (event, pointer) {\n    let moveVector = {\n      x: pointer.pageX - this.pointerDownPointer.pageX,\n      y: pointer.pageY - this.pointerDownPointer.pageY\n    };\n    this.emitEvent('pointerMove', [event, pointer, moveVector]); // start drag if pointer has moved far enough to start drag\n\n    let isDragStarting = !this.isDragging && this.hasDragStarted(moveVector);\n    if (isDragStarting) this.dragStart(event, pointer);\n    if (this.isDragging) this.dragMove(event, pointer, moveVector);\n  }; // condition if pointer has moved far enough to start drag\n\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;\n  }; // ----- drag ----- //\n\n\n  proto.dragStart = function (event, pointer) {\n    this.isDragging = true;\n    this.isPreventingClicks = true; // set flag to prevent clicks\n\n    this.emitEvent('dragStart', [event, pointer]);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    this.emitEvent('dragMove', [event, pointer, moveVector]);\n  }; // ----- end ----- //\n\n\n  proto.onmouseup = function (event) {\n    this.pointerUp(event, event);\n  };\n\n  proto.onpointerup = function (event) {\n    this.withPointer('pointerUp', event);\n  };\n\n  proto.ontouchend = function (event) {\n    this.withTouch('pointerUp', event);\n  };\n\n  proto.pointerUp = function (event, pointer) {\n    this.pointerDone();\n    this.emitEvent('pointerUp', [event, pointer]);\n\n    if (this.isDragging) {\n      this.dragEnd(event, pointer);\n    } else {\n      // pointer didn't move enough for drag to start\n      this.staticClick(event, pointer);\n    }\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    this.isDragging = false; // reset flag\n    // re-enable clicking async\n\n    setTimeout(() => delete this.isPreventingClicks);\n    this.emitEvent('dragEnd', [event, pointer]);\n  }; // triggered on pointer up & pointer cancel\n\n\n  proto.pointerDone = function () {\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n    this.unbindActivePointerEvents();\n    this.emitEvent('pointerDone');\n  }; // ----- cancel ----- //\n\n\n  proto.onpointercancel = function (event) {\n    this.withPointer('pointerCancel', event);\n  };\n\n  proto.ontouchcancel = function (event) {\n    this.withTouch('pointerCancel', event);\n  };\n\n  proto.pointerCancel = function (event, pointer) {\n    this.pointerDone();\n    this.emitEvent('pointerCancel', [event, pointer]);\n  }; // ----- click ----- //\n  // handle all clicks and prevent clicks when dragging\n\n\n  proto.onclick = function (event) {\n    if (this.isPreventingClicks) event.preventDefault();\n  }; // triggered after pointer down & up with no/tiny movement\n\n\n  proto.staticClick = function (event, pointer) {\n    // ignore emulated mouse up clicks\n    let isMouseup = event.type === 'mouseup';\n    if (isMouseup && this.isIgnoringMouseUp) return;\n    this.emitEvent('staticClick', [event, pointer]); // set flag for emulated clicks 300ms after touchend\n\n    if (isMouseup) {\n      this.isIgnoringMouseUp = true; // reset flag after 400ms\n\n      setTimeout(() => {\n        delete this.isIgnoringMouseUp;\n      }, 400);\n    }\n  }; // -----  ----- //\n\n\n  return Unidragger;\n});","map":{"version":3,"sources":["/Users/oti/Documents/QuiLib/node_modules/unidragger/unidragger.js"],"names":["window","factory","module","exports","require","Unidragger","EvEmitter","proto","prototype","Object","create","handleEvent","event","method","type","startEvent","activeEvents","PointerEvent","touchActionValue","bindHandles","_bindHandles","unbindHandles","bindMethod","touchAction","handles","forEach","handle","style","bindActivePointerEvents","eventName","addEventListener","unbindActivePointerEvents","removeEventListener","withPointer","methodName","pointerId","pointerIdentifier","withTouch","touch","changedTouch","changedTouches","identifier","onmousedown","pointerDown","ontouchstart","onpointerdown","cursorNodes","clickTypes","pointer","isCursorNode","includes","target","nodeName","isClickType","isOkayElement","isOkay","isPointerDown","button","undefined","pointerDownPointer","pageX","pageY","emitEvent","onmousemove","pointerMove","onpointermove","ontouchmove","moveVector","x","y","isDragStarting","isDragging","hasDragStarted","dragStart","dragMove","Math","abs","isPreventingClicks","onmouseup","pointerUp","onpointerup","ontouchend","pointerDone","dragEnd","staticClick","setTimeout","onpointercancel","ontouchcancel","pointerCancel","onclick","preventDefault","isMouseup","isIgnoringMouseUp"],"mappings":"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","sourcesContent":["/*!\n * Unidragger v3.0.1\n * Draggable base class\n * MIT license\n */\n\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('ev-emitter'),\n    );\n  } else {\n    // browser global\n    window.Unidragger = factory(\n        window,\n        window.EvEmitter,\n    );\n  }\n\n}( typeof window != 'undefined' ? window : this, function factory( window, EvEmitter ) {\n\nfunction Unidragger() {}\n\n// inherit EvEmitter\nlet proto = Unidragger.prototype = Object.create( EvEmitter.prototype );\n\n// ----- bind start ----- //\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  let method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\nlet startEvent, activeEvents;\nif ( 'ontouchstart' in window ) {\n  // HACK prefer Touch Events as you can preventDefault on touchstart to\n  // disable scroll in iOS & mobile Chrome metafizzy/flickity#1177\n  startEvent = 'touchstart';\n  activeEvents = [ 'touchmove', 'touchend', 'touchcancel' ];\n} else if ( window.PointerEvent ) {\n  // Pointer Events\n  startEvent = 'pointerdown';\n  activeEvents = [ 'pointermove', 'pointerup', 'pointercancel' ];\n} else {\n  // mouse events\n  startEvent = 'mousedown';\n  activeEvents = [ 'mousemove', 'mouseup' ];\n}\n\n// prototype so it can be overwriteable by Flickity\nproto.touchActionValue = 'none';\n\nproto.bindHandles = function() {\n  this._bindHandles( 'addEventListener', this.touchActionValue );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( 'removeEventListener', '' );\n};\n\n/**\n * Add or remove start event\n * @param {String} bindMethod - addEventListener or removeEventListener\n * @param {String} touchAction - value for touch-action CSS property\n */\nproto._bindHandles = function( bindMethod, touchAction ) {\n  this.handles.forEach( ( handle ) => {\n    handle[ bindMethod ]( startEvent, this );\n    handle[ bindMethod ]( 'click', this );\n    // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n    if ( window.PointerEvent ) handle.style.touchAction = touchAction;\n  } );\n};\n\nproto.bindActivePointerEvents = function() {\n  activeEvents.forEach( ( eventName ) => {\n    window.addEventListener( eventName, this );\n  } );\n};\n\nproto.unbindActivePointerEvents = function() {\n  activeEvents.forEach( ( eventName ) => {\n    window.removeEventListener( eventName, this );\n  } );\n};\n\n// ----- event handler helpers ----- //\n\n// trigger method with matching pointer\nproto.withPointer = function( methodName, event ) {\n  if ( event.pointerId === this.pointerIdentifier ) {\n    this[ methodName ]( event, event );\n  }\n};\n\n// trigger method with matching touch\nproto.withTouch = function( methodName, event ) {\n  let touch;\n  for ( let changedTouch of event.changedTouches ) {\n    if ( changedTouch.identifier === this.pointerIdentifier ) {\n      touch = changedTouch;\n    }\n  }\n  if ( touch ) this[ methodName ]( event, touch );\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  this.pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this.pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onpointerdown = function( event ) {\n  this.pointerDown( event, event );\n};\n\n// nodes that have text fields\nconst cursorNodes = [ 'TEXTAREA', 'INPUT', 'SELECT', 'OPTION' ];\n// input types that do not have text fields\nconst clickTypes = [ 'radio', 'checkbox', 'button', 'submit', 'image', 'file' ];\n\n/**\n * any time you set `event, pointer` it refers to:\n * @param {Event} event\n * @param {Event | Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  // dismiss multi-touch taps, right clicks, and clicks on text fields\n  let isCursorNode = cursorNodes.includes( event.target.nodeName );\n  let isClickType = clickTypes.includes( event.target.type );\n  let isOkayElement = !isCursorNode || isClickType;\n  let isOkay = !this.isPointerDown && !event.button && isOkayElement;\n  if ( !isOkay ) return;\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n  // track position for move\n  this.pointerDownPointer = {\n    pageX: pointer.pageX,\n    pageY: pointer.pageY,\n  };\n\n  this.bindActivePointerEvents();\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// ----- move ----- //\n\nproto.onmousemove = function( event ) {\n  this.pointerMove( event, event );\n};\n\nproto.onpointermove = function( event ) {\n  this.withPointer( 'pointerMove', event );\n};\n\nproto.ontouchmove = function( event ) {\n  this.withTouch( 'pointerMove', event );\n};\n\nproto.pointerMove = function( event, pointer ) {\n  let moveVector = {\n    x: pointer.pageX - this.pointerDownPointer.pageX,\n    y: pointer.pageY - this.pointerDownPointer.pageY,\n  };\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  // start drag if pointer has moved far enough to start drag\n  let isDragStarting = !this.isDragging && this.hasDragStarted( moveVector );\n  if ( isDragStarting ) this.dragStart( event, pointer );\n  if ( this.isDragging ) this.dragMove( event, pointer, moveVector );\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n// ----- drag ----- //\n\nproto.dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  this.isPreventingClicks = true; // set flag to prevent clicks\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// ----- end ----- //\n\nproto.onmouseup = function( event ) {\n  this.pointerUp( event, event );\n};\n\nproto.onpointerup = function( event ) {\n  this.withPointer( 'pointerUp', event );\n};\n\nproto.ontouchend = function( event ) {\n  this.withTouch( 'pointerUp', event );\n};\n\nproto.pointerUp = function( event, pointer ) {\n  this.pointerDone();\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n\n  if ( this.isDragging ) {\n    this.dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this.staticClick( event, pointer );\n  }\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.isDragging = false; // reset flag\n  // re-enable clicking async\n  setTimeout( () => delete this.isPreventingClicks );\n\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// triggered on pointer up & pointer cancel\nproto.pointerDone = function() {\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n  this.unbindActivePointerEvents();\n  this.emitEvent('pointerDone');\n};\n\n// ----- cancel ----- //\n\nproto.onpointercancel = function( event ) {\n  this.withPointer( 'pointerCancel', event );\n};\n\nproto.ontouchcancel = function( event ) {\n  this.withTouch( 'pointerCancel', event );\n};\n\nproto.pointerCancel = function( event, pointer ) {\n  this.pointerDone();\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// ----- click ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) event.preventDefault();\n};\n\n// triggered after pointer down & up with no/tiny movement\nproto.staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  let isMouseup = event.type === 'mouseup';\n  if ( isMouseup && this.isIgnoringMouseUp ) return;\n\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( isMouseup ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 400ms\n    setTimeout( () => {\n      delete this.isIgnoringMouseUp;\n    }, 400 );\n  }\n};\n\n// -----  ----- //\n\nreturn Unidragger;\n\n} ) );\n"]},"metadata":{},"sourceType":"script"}